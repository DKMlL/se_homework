# 变量初始化原则
***

## 不正确的变量初始化  
不合理的初始化数据是产生编程错误的常见根源之一。以下行为会产生此类问题：
- 从未对变量赋值。
  例：只定义没赋值就使用
- 变量值已经过期，变量的值不再有效。
  例：将变量再次使用时可能会发生
- 变量的一部分被赋值，而另一部分没有
  例：初始化一个对象的部分成员，而不是全部成员

## 避免错误的建议
1. 在声明变量时就初始化
2. 在靠近变量第一次使用时初始化
   >就近原则：把相关的操作放在一起。这项原则也适用于让注释靠近它所描述的代码，让控制循环的代码靠近循环本身等。
   **理想情况下，在靠近第一次使用变量的位置声明和定义该变量**
3. 在可能的情况下使用final或者const
    >在Java里把变量声明为final，在C++里吧变量声明为const。防止变量初始化后再被赋值
4. 特别注意计数器和累加器
    >i,j,k,sum和total等常用来作为计数器和累加器，记得在下一次使用时重置
5. 在类的构造函数里初始化该类的数据成员
    >正如子程序的变量应该在每一个子程序内部初始化一样。类的数据也应该在其构造函数初始化
6. 检查是否需要重新初始化
    >可能子程序内定某个循环多次使用变量，因此需要重新初始化
7. 一次性初始化具名常量；用可执行代码啦初始化变量
    >如果你想用变量来模拟具名常量，那么在程序开始处对常量做一次初始化即可。你可以用一个Startup(子程序去初始化它们。对于真正的变量，则应在靠近它们使用的位置
    用可执行代码(executable code)对其初始化。对程序常做的修改之一就是把一个
    原本只调用一次的子程序修改为可以调用多次。那些由系统级的Startup()子程
    序进行初始化的变量不会再由该子程序重新初始化。
8. 使用编译器设置来自动初始化所有变量
    >如果编译器支持自动初始化所有变量的选项，把它打开。这是一种靠编译器完成初始化工作的简单方式。但是当把代码移植到另一台机器或者编译器的时候，依赖特定的编译器设置就会带来问题。确保记下了编译器设置。
9. 利用编译器的警告信息
    >很多编译器会在你使用了未经初始化的变量的时候发出警告。
10. 检查输入参数的合法性
    >把输入数值赋给任何对象之前，要确保这些数值是合理的。
11. 使用内存访问检查工具来检查错误的指针
    >可以购买内存访问程检查工具(memory-access cheeker)来检测你的程序中的内存操作。
12. 在程序开始时初始化工作内存
    >把工作内存(working memory)初始化为一个已知数值将会有助于发现初始化错误。可以用某种在程序运行前预先填充内存的工具(memory filler)来把程序的工作内存填充为一个可以预料的值。对于某些检测目的而言，0是个很好的填充值，因为它会确保那些尚未初始化的指针指向内存底端，很容易就能检测出误用未初始化的指针的情况。


****
# 为变量指定单一用途
- 每个变量只用于单一内容
  例：避免两个场合使用同一个变量，例如常用变量temp 
- 避免让代码具有隐含含义
  例：如果pagenumber代表书本的页数，当它=-1时表示错误。实际上这样混淆了整数和布尔，这是常犯错误。
- 确保使用了所有已经声明的变量

****
#核对表：使用数据的一般事项
- 变量声明位置靠近变量第一次使用的位置吗?
- 尽可能地在声明变量的同时初始化变量吗?
- 如果无法同时声明和初始化变量，有没有在靠近第一次使用变量的位置声明变量?
- 计数器和累加器经过了适当的初始化吗?如果需要再一次使用，之前重新初始化了吗?
- 适当地重新初始化“需要重复执行的代码里的变量”了吗?
- 代码在通过编译器编译的时候是不是没有警告信息?(你启用了所有可用的警告选项了吗?)
- 每个变量都有且仅有一项用途吗?
- 所有声明的变量都用到了吗?